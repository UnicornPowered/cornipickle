/*
    Automated fault localization in discrete structures
    Copyright (C) 2006-2017 Sylvain Hall√©

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package ca.uqac.lif.cornipickle.faultfinder;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * Utility class used to measure running time and number of solutions
 * produced by the fault iterator.
 * @author Sylvain
 *
 */
public class Meter<T>
{
	protected final FaultIterator<T> m_iterator;
	
	/**
	 * Time it takes to enumerate all solutions, in seconds
	 */
	protected float m_duration = 0;
	
	/**
	 * The number of solutions generated by the iterator
	 */
	protected long m_numSolutions = 0;
	
	/**
	 * The maximum cardinality of the solutions to generate
	 */
	protected long m_upperBound = 0;
	
	/**
	 * The distribution of the number of solutions by size
	 */
	protected Map<Long,Long> m_solutionDistribution;
	
	/**
	 * The distribution of the number of candidate solutions by size
	 */
	protected Map<Long,Long> m_candidatesDistribution;
	
	/**
	 * Time to the first solution generated
	 */
	protected float m_timeToFirst = 0;
	
	/**
	 * A class to call for every solution generated 
	 */
	protected SolutionCallback<T> m_solutionCallback = null;
	
	public Meter(FaultIterator<T> it, long upper_bound)
	{
		super();
		m_iterator = it;
		m_iterator.setMaxSize(upper_bound);
		m_upperBound = upper_bound;
		m_solutionDistribution = new HashMap<Long,Long>();
		m_candidatesDistribution = new HashMap<Long,Long>();
	}
	
	public Meter<T> setCallback(SolutionCallback<T> c)
	{
		m_solutionCallback = c;
		return this;
	}
	
	public void run()
	{
		long start_time = System.currentTimeMillis();
		while (m_iterator.hasNext())
		{
			Set<? extends Transformation<T>> transformation = m_iterator.next();
			if (m_timeToFirst == 0)
			{
				m_timeToFirst = (System.currentTimeMillis() - start_time) / 1000f;
			}
			if (m_solutionCallback != null)
			{
				m_solutionCallback.doWith(transformation);
			}
			incrementToMap(m_solutionDistribution, transformation.size(), 1);
			m_candidatesDistribution.put((long) transformation.size(), m_iterator.getSolutionsExplored());
		}
		long end_time = System.currentTimeMillis();
		m_duration = (end_time - start_time) / 1000f;
		m_numSolutions = m_iterator.getValidSolutions();
	}
	
	protected static void incrementToMap(Map<Long,Long> map, long x, long increment)
	{
		long value = 0;
		if (map.containsKey(x))
		{
			value = map.get(x);
		}
		map.put(x, value + increment);
	}
	
	public Map<Long,Long> getSolutionDistribution()
	{
		return m_solutionDistribution;
	}
	
	public Map<Long,Long> getCandidatesDistribution()
	{
		return m_candidatesDistribution;
	}
	
	public long getNumSolutions()
	{
		return m_numSolutions;
	}
	
	public abstract static class SolutionCallback<T>
	{
		public abstract void doWith(Set<? extends Transformation<T>> transformation); 
	}
	
	public float getDuration()
	{
		return m_duration;
	}
	
	public String toString()
	{
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		PrintStream ps = new PrintStream(baos);
		ps.printf("Duration:\t%f\n", m_duration);
		ps.printf("Time to first:\t%f\n", m_timeToFirst);
		ps.printf("Solutions:\t%d/%d\n", m_numSolutions, m_iterator.getSolutionsExplored());
		ps.printf("Speed:   \t%f Hz\n", m_numSolutions / m_duration);
		ps.printf("Solution distribution:\n%s\n", m_solutionDistribution);
		ps.printf("Candidate distribution:\n%s\n", m_candidatesDistribution);
		String content = baos.toString();
		ps.close();
		try {
			baos.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return content;
	}
}
